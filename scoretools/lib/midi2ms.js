// Generated by CoffeeScript 1.11.1
(function() {
  var deltaTime, dt, event, file, fs, i, j, k, l, len, len1, len2, len3, len4, m, mapi, microseconds, microsecondsPerBeat, midi, midiFileParser, midifilein, midifileout, midiout, output, outputBuffer, ref, ref1, ref2, tempomap, ticksPerBeat, timeMicroseconds, timeTicks, track, trackout, writeMidi, writtenTempo;

  if (process.argv.length !== 4) {
    console.error('Usage: node readmidi.js MIDIFILEIN MIDIFILEOUT');
    process.exit(-1);
  }

  midiFileParser = require('midi-file-parser');

  writeMidi = require('midi-file').writeMidi;

  fs = require('fs');

  midifilein = process.argv[2];

  midifileout = process.argv[3];

  console.log('read ' + midifilein);

  file = fs.readFileSync(midifilein, 'binary');

  midi = midiFileParser(file);

  ref = midi.tracks;
  for (i = 0, len = ref.length; i < len; i++) {
    track = ref[i];
    for (j = 0, len1 = track.length; j < len1; j++) {
      event = track[j];
      event.type = event.subtype;
      delete event.subtype;
    }
  }

  if (!midi.header.ticksPerBeat) {
    console.error('File is not beat-based: ' + (JSON.stringify(midi.header)));
    process.exit(-2);
  }

  ticksPerBeat = midi.header.ticksPerBeat;

  microsecondsPerBeat = 500000;

  delete midi.header.ticksPerBeat;

  midi.header.ticksPerBeat = 500;

  midiout = {
    header: midi.header,
    tracks: []
  };

  tempomap = [];

  tempomap.push({
    timeTicks: 0,
    timeMicroseconds: 0,
    microsecondsPerBeat: microsecondsPerBeat
  });

  if (midi.tracks.length === 0) {
    console.error('ERROR: file contains no tracks');
  } else {
    console.log('reading tempo information from first track');
    timeMicroseconds = 0;
    timeTicks = 0;
    ref1 = midi.tracks[0];
    for (k = 0, len2 = ref1.length; k < len2; k++) {
      event = ref1[k];
      if (event.deltaTime != null) {
        timeTicks += event.deltaTime;
        microseconds = Math.round(microsecondsPerBeat * event.deltaTime / ticksPerBeat);
        timeMicroseconds += microseconds;
      } else {
        console.log(event);
      }
      if (event.type === 'setTempo') {
        microsecondsPerBeat = event.microsecondsPerBeat;
        console.log('at ' + (timeMicroseconds / 1000000) + ' tempo now ' + microsecondsPerBeat + 'us/beat = ' + (60000000 / microsecondsPerBeat) + ' bpm');
        tempomap.push({
          timeTicks: timeTicks,
          timeMicroseconds: timeMicroseconds,
          microsecondsPerBeat: microsecondsPerBeat
        });
      }
    }
  }

  ref2 = midi.tracks;
  for (l = 0, len3 = ref2.length; l < len3; l++) {
    track = ref2[l];
    trackout = [];
    midiout.tracks.push(trackout);
    mapi = 0;
    timeTicks = 0;
    timeMicroseconds = 0;
    microsecondsPerBeat = tempomap[mapi++].microsecondsPerBeat;
    writtenTempo = false;
    for (m = 0, len4 = track.length; m < len4; m++) {
      event = track[m];
      if (event.deltaTime != null) {
        deltaTime = event.deltaTime;
        microseconds = 0;
        while (deltaTime > 0) {
          if (mapi < tempomap.length && timeTicks + deltaTime >= tempomap[mapi].timeTicks) {
            dt = tempomap[mapi].timeTicks - timeTicks;
            if (dt > 0) {
              microseconds += microsecondsPerBeat * dt / ticksPerBeat;
              deltaTime -= dt;
              timeTicks += dt;
            }
            microsecondsPerBeat = tempomap[mapi++].microsecondsPerBeat;
            continue;
          }
          microseconds += microsecondsPerBeat * deltaTime / ticksPerBeat;
          timeTicks += deltaTime;
          break;
        }
        microseconds = Math.round(microseconds);
        event.deltaTime = Math.floor((microseconds + (timeMicroseconds % 1000)) / 1000);
        timeMicroseconds += microseconds;
      } else {
        console.log('no deltaTime: ' + event);
      }
      if (event.type === 'setTempo') {
        microsecondsPerBeat = event.microsecondsPerBeat;
        console.log('check: at ' + (timeMicroseconds / 1000000) + ' tempo now ' + microsecondsPerBeat + 'us/beat = ' + (60000000 / microsecondsPerBeat) + ' bpm');
        if (!writtenTempo) {
          writtenTempo = true;
          event.microsecondsPerBeat = 500000;
          trackout.push(event);
        }
      } else {
        trackout.push(event);
      }
      if (event.type === 'endOfTrack') {
        console.log('end of track: at ' + (timeMicroseconds / 1000000) + ' s = ' + timeTicks + ' ticks, average ' + (60 * timeTicks / ticksPerBeat * 1000000 / timeMicroseconds) + ' bpm');
      }
    }
  }

  console.log('ok');

  output = writeMidi(midiout);

  outputBuffer = new Buffer(output);

  console.log('writing ' + midifileout);

  fs.writeFileSync(midifileout, outputBuffer);

  console.log('done');

}).call(this);
