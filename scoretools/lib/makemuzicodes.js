// Generated by CoffeeScript 1.11.1
(function() {
  var BITS_PER_FLAGVAR, add_actions, add_delayed_mc, add_delayed_midi, add_delayed_visual, add_immediate_actions, cell, cellid, challengecount, channel, climbview, codetitles, config, configdir, configfile, content_url, control, ct, cuesingle, data, defaultprojection, delayid, e, effects, errors, ex, exinfile, exoutfile, fragment, fragments, fs, getCodeIds, get_marker, getfragmentids, guid, i, i1, j, j1, k, k1, l, l1, len, len1, len10, len11, len2, len3, len4, len5, len6, len7, len8, len9, m1, marker, markernames, maxdelay, maxrow, mc, mcs, mei, meicolorapp, meicolorcue, meicolormidi, meicolorother, meiids, meitext, meiutils, meldmc, meldout, meldoutfile, meldstage, mi, midi, mindelay, n1, nextexp, nextstage, nextstages, nexturi, nmidis, note, notes, numflagvars, numstages, o, o1, p, path, pix, pmidis, pnotes, prefix, prefixes, processmeifile, q, r, readmeifile, readmeiids, readrow, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref3, ref4, ref5, ref6, ref7, ref8, ref9, relpath, set_stage, sfi, sheet, stage, stages, sweathers, t, title, u, unused, v, viewconfig, viewgen, viewoutfile, w, weather_urls, weatherdelay, weathers, wi, workbook, writemeifile, x, xlfile, xlsx, y, yaml, z;

  if (process.argv.length !== 2 && process.argv.length !== 3) {
    console.log('Usage: node makemuzicodes [<config.yaml>]');
    process.exit(-1);
  }

  yaml = require('js-yaml');

  fs = require('fs');

  path = require('path');

  getCodeIds = (require('./meiutils')).getCodeIds;

  meiutils = require('./meiutils');

  climbview = require('./climbview');

  configfile = (ref = process.argv[2]) != null ? ref : 'config.yml';

  configfile = path.normalize(configfile);

  configdir = path.isAbsolute(configfile) ? path.dirname(configfile) : path.join(process.cwd(), path.dirname(configfile));

  console.log('read config ' + configfile + ' from ' + configdir);

  config = {};

  try {
    config = yaml.safeLoad(fs.readFileSync(configfile, 'utf8'));
    console.log(config);
  } catch (error) {
    e = error;
    console.log('error reading config ' + configfile + ': ' + e.message);
    process.exit(-2);
  }

  relpath = function(p, base) {
    if (path.isAbsolute(p)) {
      return p;
    } else {
      return path.normalize(path.join(base, p));
    }
  };

  xlfile = relpath(config.spreadsheet, configdir);

  exinfile = relpath(config.experiencein, configdir);

  exoutfile = relpath(config.experienceout, configdir);

  viewoutfile = relpath(config.climbviewout, configdir);

  meldoutfile = relpath(config.meldout, configdir);

  viewgen = climbview.generator('Climbview ' + viewoutfile + ' from ' + configfile, config);

  xlsx = require('xlsx');

  fs = require('fs');

  console.log('read template experience ' + exinfile);

  ex = JSON.parse(fs.readFileSync(exinfile, {
    encoding: 'utf8'
  }));

  meldout = [];

  console.log('read spreadsheet ' + xlfile);

  workbook = xlsx.readFile(xlfile);

  sheet = workbook.Sheets[workbook.SheetNames[0]];

  cellid = function(c, r) {
    var p, rec;
    p = String(r + 1);
    rec = function(c) {
      p = (String.fromCharCode('A'.charCodeAt(0) + (c % 26))) + p;
      c = Math.floor(c / 26);
      if (c !== 0) {
        return rec(c - 1);
      }
    };
    rec(c);
    return p;
  };

  readrow = function(r) {
    var c, data, head, i, key, prefix, ref1, ref2, ref3, ref4, val;
    data = {};
    prefix = '';
    for (c = i = 0; i <= 1000; c = ++i) {
      head = (ref1 = sheet[cellid(c, 0)]) != null ? (ref2 = ref1.v) != null ? ref2.toLowerCase() : void 0 : void 0;
      if (head == null) {
        break;
      }
      if ((head.indexOf(':')) >= 0) {
        prefix = (head.substring(0, head.indexOf(':'))) + '_';
        head = head.substring((head.indexOf(':')) + 1);
      }
      key = prefix + head;
      val = (ref3 = sheet[cellid(c, r)]) != null ? ref3.v : void 0;
      if (val != null) {
        data[key] = (ref4 = sheet[cellid(c, r)]) != null ? ref4.v : void 0;
      }
    }
    return data;
  };

  if (ex.markers == null) {
    ex.markers = [];
  }

  ex.controls = [];

  if (ex.parameters == null) {
    ex.parameters = {};
  }

  markernames = [];

  ref1 = ex.markers;
  for (i = 0, len = ref1.length; i < len; i++) {
    marker = ref1[i];
    if (marker.title && (markernames.indexOf(marker.title)) >= 0) {
      console.log('WARNING: marker "' + marker.title + '" defined multiple times');
    }
    marker.actions = [];
    delete marker.action;
    delete marker.precondition;
    marker.poststate = {};
    marker.precondition = '';
  }

  ex.parameters.initstate = {
    stage: '""',
    cued: false,
    meldmei: '""',
    meldsession: '""',
    meldsessionpost: '""',
    meldnextmeifile: 'null',
    mcserver: JSON.stringify((ref2 = config.mcserver) != null ? ref2 : 'http://localhost:3000/input'),
    meldscoreuri: JSON.stringify((ref3 = config.meldscoreuri) != null ? ref3 : 'http://127.0.0.1:5000/score/'),
    meldmeiuri: JSON.stringify((ref4 = config.meldmeiuri) != null ? ref4 : 'http://127.0.0.1:3000/content/'),
    contenturi: JSON.stringify((ref5 = config.contenturi) != null ? ref5 : 'http://localhost:3000/content/'),
    performanceid: '""',
    performancename: '""',
    stagecodeflags: 0
  };

  if (config.performances) {
    ref6 = config.performances;
    for (title in ref6) {
      guid = ref6[title];
      ex.controls.push({
        inputUrl: 'button:Perform ' + title,
        actions: [],
        poststate: {
          performanceid: JSON.stringify(guid),
          performancename: JSON.stringify(title)
        }
      });
      ex.controls.push({
        inputUrl: 'post:performanceid',
        actions: [],
        poststate: {
          performanceid: 'params.performanceid',
          performancename: 'params.performancename'
        }
      });
    }
  }

  ex.controls.push({
    inputUrl: 'button:Stop app',
    actions: [
      {
        url: 'emit:vStop:mobileapp:{{performanceid}}'
      }
    ]
  });

  defaultprojection = String((ref7 = config.defaultprojection) != null ? ref7 : '');

  if (defaultprojection === '') {
    console.log("WARNING: defaultprojection is not defined in " + configfile);
  } else {
    if (((ref8 = (function() {
      var j, len1, ref10, ref9, results;
      ref10 = (ref9 = ex.projections) != null ? ref9 : [];
      results = [];
      for (j = 0, len1 = ref10.length; j < len1; j++) {
        p = ref10[j];
        if (p.id === defaultprojection) {
          results.push(p);
        }
      }
      return results;
    })()) != null ? ref8 : []).length === 0) {
      console.log('WARNING: cannot find default projection "' + defaultprojection + '"');
    } else {
      console.log('using default projection "' + defaultprojection + '"');
    }
  }

  cuesingle = (ref9 = config.cuesingle) != null ? ref9 : false;

  stages = {};

  prefixes = ['auto_', 'mc1_', 'mc2_', 'mc3_', 'mc4_', 'mc5_', 'default_'];

  mcs = ['mc1_', 'mc2_', 'mc3_', 'mc4_', 'mc5_'];

  weathers = ['no', 'wind', 'rain', 'snow', 'sun', 'storm'];

  effects = '[';

  weather_urls = '[';

  sweathers = '[';

  for (wi = j = 0, len1 = weathers.length; j < len1; wi = ++j) {
    w = weathers[wi];
    if (wi > 0) {
      sweathers += ',';
    }
    sweathers += JSON.stringify(w);
    if (config[w + '_effect'] == null) {
      console.log('ERROR: ' + w + '_effect not defined in ' + configfile);
    }
    if (wi > 0) {
      effects += ',';
    }
    effects += JSON.stringify(config[w + '_effect']);
    if (config[w + '_url'] == null) {
      console.log('ERROR: ' + w + '_url not defined in ' + configfile);
    }
    if (wi > 0) {
      weather_urls += ',';
    }
    weather_urls += JSON.stringify(config[w + '_url']);
    control = {
      inputUrl: 'delay:' + w,
      actions: []
    };
    control.actions.push({
      channel: '',
      url: config[w + '_effect']
    });
    control.actions.push({
      channel: 'v.weather',
      url: config[w + '_url']
    });
    ex.controls.push(control);
  }

  effects += ']';

  weather_urls += ']';

  sweathers += ']';

  ex.parameters.initstate.effects = effects;

  ex.parameters.initstate.weather_urls = weather_urls;

  ex.parameters.initstate.weathers = sweathers;

  mindelay = Number((ref10 = config.weatherdelaymin) != null ? ref10 : 0);

  maxdelay = Number((ref11 = config.weatherdelaymax) != null ? ref11 : 0);

  weatherdelay = '' + mindelay + '+Math.random()*' + (maxdelay - mindelay);

  if (maxdelay < mindelay) {
    maxdelay = mindelay;
  }

  content_url = function(url) {
    if ((url.indexOf(':')) < 0 && (url.substring(0, 1)) !== '/') {
      return '{{contenturi}}' + url;
    } else {
      return url;
    }
  };

  delayid = 0;

  numstages = 0;

  BITS_PER_FLAGVAR = 31;

  numflagvars = 0;

  add_actions = function(control, prefix, data, meldload) {
    var delay, delaycontrol, err, vdelta;
    add_immediate_actions(control, prefix, data, meldload);
    if (data[prefix + 'delay'] != null) {
      try {
        delay = Number(data[prefix + 'delay']);
        vdelta = data[prefix + 'vdelta'] != null ? Number(data[prefix + 'vdelta']) : 0;
        delaycontrol = {
          inputUrl: 'delay:' + (delayid++) + ':' + data.stage + ':' + prefix,
          actions: []
        };
        ex.controls.push(delaycontrol);
        add_delayed_midi(delaycontrol, prefix, data, meldload);
        if (vdelta === 0) {
          add_delayed_visual(delaycontrol, prefix, data, meldload);
        }
        control.actions.push({
          url: delaycontrol.inputUrl,
          delay: delay
        });
        if (vdelta !== 0) {
          delay += vdelta;
          if (delay < 0) {
            console.log('Warning: negative delay for ' + prefix + ' visuals in ' + data.stage);
            delay = 0;
          }
          delaycontrol = {
            inputUrl: 'delay:' + (delayid++) + ':' + data.stage + ':v' + prefix,
            actions: []
          };
          ex.controls.push(delaycontrol);
          add_delayed_visual(delaycontrol, prefix, data, meldload);
          control.actions.push({
            url: delaycontrol.inputUrl,
            delay: delay
          });
        }
      } catch (error) {
        err = error;
        console.log('ERROR: adding delay of ' + data[prefix + 'delay'] + ' (vdelta ' + data[prefix + 'vdelta'] + ') for ' + data.stage + ' ' + prefix + ' (' + err.message + ')');
      }
    } else {
      add_delayed_visual(control, prefix, data, meldload);
      add_delayed_midi(control, prefix, data, meldload);
    }
    if (data[prefix + 'v.mc.delay'] != null) {
      try {
        delay = Number(data[prefix + 'v.mc.delay']);
        delaycontrol = {
          inputUrl: 'delay:' + (delayid++) + ':' + data.stage + ':' + prefix,
          actions: []
        };
        ex.controls.push(delaycontrol);
        add_delayed_mc(delaycontrol, prefix, data, meldload);
        return control.actions.push({
          url: delaycontrol.inputUrl,
          delay: delay
        });
      } catch (error) {
        err = error;
        return console.log('ERROR: adding delay of ' + data[prefix + 'v.mc.delay'] + ' for ' + data.stage + ' ' + prefix + ' (' + err.message + ')');
      }
    } else {
      return add_delayed_mc(control, prefix, data, meldload);
    }
  };

  add_immediate_actions = function(control, prefix, data, meldload) {
    var channel, l, len2, len3, len4, msg, msgs, nextstage, nextstages, nomeld, ns, o, q, ref12, ref13, ref14, sfbi, sfi, stageflags, stagetest, t, text, u;
    control.actions.push({
      channel: '',
      url: content_url(data[prefix + 'monitor'])
    });
    ref12 = ['v.background', 'v.mc'];
    for (l = 0, len2 = ref12.length; l < len2; l++) {
      channel = ref12[l];
      if (data[prefix + channel] != null) {
        if (channel === 'v.mc' && String(data[prefix + channel]) === '1') {
          if (config.defaultmuzicodeurl != null) {
            control.actions.push({
              channel: channel,
              url: content_url(config.defaultmuzicodeurl)
            });
          } else {
            console.log('ERROR: use of undefined defaultmuzicodeurl in ' + prefix + channel);
          }
        } else if (!(channel === 'v.background' && (config.forcebackgroundurl != null))) {
          viewgen.add(data[prefix + channel]);
          control.actions.push({
            channel: channel,
            url: content_url(data[prefix + channel])
          });
        }
      }
    }
    if (data[prefix + 'midi'] != null) {
      msgs = data[prefix + 'midi'].split(',');
      for (o = 0, len3 = msgs.length; o < len3; o++) {
        msg = msgs[o];
        msg = msg.trim();
        if (msg.length > 0) {
          control.actions.push({
            channel: '',
            url: 'data:text/x-midi-hex,' + msg
          });
        }
      }
    }
    if (control.poststate == null) {
      control.poststate = {};
    }
    if (control.precondition == null) {
      control.precondition = '';
    }
    if (data[prefix + 'cue'] != null) {
      if ((cuesingle && prefix !== 'auto_' && control.precondition.indexOf('cued')) < 0) {
        control.precondition = '!cued' + (control.precondition.length === 0 ? '' : ' && (') + control.precondition + (control.precondition.length === 0 ? '' : ')');
      }
      if ((data.next != null) && (stages[data.next] == null)) {
        console.log('ERROR: stage ' + data.stage + ' has unknown safe next stage ' + data.next);
      }
      nextstages = ((data[prefix + 'cue'].split('/')).map((function(_this) {
        return function(s) {
          return s.trim();
        };
      })(this))).filter((function(_this) {
        return function(s) {
          return s.length > 0;
        };
      })(this));
      nomeld = prefix !== 'auto_';
      if (nomeld && nextstages.length > 1) {
        console.log('ERROR: stage ' + data.stage + ' non-auto cue ' + prefix + ' has multiple next stages; will get out of sync with MELD!');
      }
      text = 'delay:stage' + (nomeld ? '_nomeld' : '') + ':{{chooseOne(';
      for (q = 0, len4 = nextstages.length; q < len4; q++) {
        nextstage = nextstages[q];
        text = text + (JSON.stringify(nextstage)) + ',';
        stagetest = 'true';
        if ((nextstage != null) && (data.next != null) && (stages[nextstage] != null) && (stages[data.next] != null) && nextstage !== data.next) {
          stageflags = [];
          for (sfi = t = 1, ref13 = numflagvars; 1 <= ref13 ? t <= ref13 : t >= ref13; sfi = 1 <= ref13 ? ++t : --t) {
            stageflags[sfi - 1] = 0;
          }
          ns = nextstage;
          while ((ns != null) && (stages[ns] != null)) {
            sfi = Math.floor(stages[ns]._index / BITS_PER_FLAGVAR);
            sfbi = stages[ns]._index % BITS_PER_FLAGVAR;
            if ((stageflags[sfi] & (1 << sfbi)) !== 0) {
              console.log('ERROR: safe route from ' + nextstage + ' has a loop at ' + ns);
              break;
            }
            stageflags[sfi] = stageflags[sfi] | (1 << sfbi);
            ns = stages[ns].next;
          }
          stagetest = '';
          for (sfi = u = 1, ref14 = numflagvars; 1 <= ref14 ? u <= ref14 : u >= ref14; sfi = 1 <= ref14 ? ++u : --u) {
            if (stagetest.length > 0) {
              stagetest += ' && ';
            }
            stagetest += '(stageflags' + (sfi - 1) + ' & ' + stageflags[sfi - 1] + ')==0';
          }
        }
        text = text + stagetest + ',';
      }
      text = text + (JSON.stringify(data.next)) + ')}}';
      return control.actions.push({
        url: text
      });
    }
  };

  add_delayed_visual = function(control, prefix, data, meldload) {
    var channel, l, len2, ref12, results;
    ref12 = ['v.animate'];
    results = [];
    for (l = 0, len2 = ref12.length; l < len2; l++) {
      channel = ref12[l];
      if (data[prefix + channel] != null) {
        viewgen.add(data[prefix + channel]);
        results.push(control.actions.push({
          channel: channel,
          url: content_url(data[prefix + channel])
        }));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  add_delayed_mc = function(control, prefix, data, meldload) {
    var channel, l, len2, ref12;
    ref12 = ['v.mc2'];
    for (l = 0, len2 = ref12.length; l < len2; l++) {
      channel = ref12[l];
      if (data[prefix + channel] != null) {
        if (channel === 'v.mc2' && String(data[prefix + channel]) === '1') {
          if (config.defaultmuzicodeurl != null) {
            control.actions.push({
              channel: 'v.mc',
              url: content_url(config.defaultmuzicodeurl)
            });
          } else {
            console.log('ERROR: use of undefined defaultmuzicodeurl in ' + prefix + channel);
          }
        } else if (!(channel === 'v.background' && (config.forcebackgroundurl != null))) {
          viewgen.add(data[prefix + channel]);
          control.actions.push({
            channel: channel === 'v.mc2' ? 'v.mc' : channel,
            url: content_url(data[prefix + channel])
          });
        }
      }
    }
    if (data[prefix + 'app'] != null) {
      return control.actions.push({
        url: 'emit:vEvent:mobileapp:{{performanceid}}:' + data[prefix + 'app']
      });
    }
  };

  add_delayed_midi = function(control, prefix, data, meldload) {
    var l, len2, msg, msgs, results;
    if (data[prefix + 'midi2'] != null) {
      msgs = data[prefix + 'midi2'].split(',');
      results = [];
      for (l = 0, len2 = msgs.length; l < len2; l++) {
        msg = msgs[l];
        msg = msg.trim();
        if (msg.length > 0) {
          results.push(control.actions.push({
            channel: '',
            url: 'data:text/x-midi-hex,' + msg
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  set_stage = function(control, data) {
    var l, len2, n, ni, o, ref12, sfbi, sfi, ws;
    if (control.poststate == null) {
      control.poststate = {};
    }
    control.poststate.cued = "false";
    control.poststate.stage = JSON.stringify(data.stage);
    control.poststate.stagecodeflags = '0';
    sfi = Math.floor(data._index / BITS_PER_FLAGVAR);
    sfbi = data._index % BITS_PER_FLAGVAR;
    control.poststate['stageflags' + sfi] = 'stageflags' + sfi + ' | ' + (1 << sfbi);
    ws = [];
    for (wi = l = 0, len2 = weathers.length; l < len2; wi = ++l) {
      w = weathers[wi];
      if ((data[w + '_effect'] != null) && data[w + '_effect'].length > 0) {
        if (data[w + '_effect'].substring(0, 1).toLowerCase() === 'y') {
          ws.push(wi);
        } else if (data[w + '_effect'].substring(0, 1).toLowerCase() !== 'n') {
          n = parseInt(data[w + '_effect']);
          if (isNaN(n)) {
            console.log('WARNING: error in weather ' + w + ' value ' + data[w + '_effect'] + ' (should be Y, N or count)');
          }
          if (!(isNaN(n)) && n > 0) {
            for (ni = o = 1, ref12 = n; 1 <= ref12 ? o <= ref12 : o >= ref12; ni = 1 <= ref12 ? ++o : --o) {
              ws.push(wi);
            }
          }
        }
      }
    }
    if (ws.length > 0) {
      return control.actions.push({
        url: 'delay:{{weathers[([' + (ws.join(',')) + '])[Math.floor(Math.random()*' + ws.length + ')]]}}',
        delay: weatherdelay
      });
    }
  };

  get_marker = function(ex, markertitle, optdescription) {
    var l, len2, markers, ref12;
    markers = (ref12 = (function() {
      var l, len2, ref13, results;
      ref13 = ex.markers;
      results = [];
      for (l = 0, len2 = ref13.length; l < len2; l++) {
        marker = ref13[l];
        if (marker.title === markertitle) {
          results.push(marker);
        }
      }
      return results;
    })()) != null ? ref12 : [];
    for (l = 0, len2 = markers.length; l < len2; l++) {
      marker = markers[l];
      if (marker.actions.length === 0 && marker.precondition.length === 0) {
        return marker;
      }
    }
    if (markers.length === 0) {
      console.log('WARNING: marker  "' + markertitle + '" undefined - adding to output');
      marker = {
        title: markertitle,
        description: optdescription,
        poststate: {},
        actions: [],
        precondition: ''
      };
      ex.markers.push(marker);
      return marker;
    }
    console.log('NOTE: marker "' + markertitle + '" used more than once; cloning');
    marker = JSON.parse(JSON.stringify(markers[0]));
    marker.poststate = {};
    marker.actions = [];
    marker.precondition = '';
    ex.markers.push(marker);
    return marker;
  };

  maxrow = 1;

  for (r = l = 1; l <= 1000; r = ++l) {
    cell = sheet[cellid(0, r)];
    if (cell === void 0) {
      break;
    }
    data = readrow(r);
    if (data.stage == null) {
      console.log('ignore row without stage name: ' + (JSON.stringify(data)));
      continue;
    }
    console.log('stage ' + data.stage);
    maxrow = r;
    if (stages[data.stage] !== void 0) {
      console.log('ERROR: more than one entry found for stage ' + data.stage);
    }
    data._index = numstages;
    numstages++;
    stages[data.stage] = data;
    for (o = 0, len2 = prefixes.length; o < len2; o++) {
      prefix = prefixes[o];
      if (data[prefix + 'monitor'] == null) {
        if (prefix === 'auto_') {
          data[prefix + 'monitor'] = 'data:text/plain,stage ' + data.stage + ' ' + prefix + ' triggered!';
        } else if (data[prefix + 'cue']) {
          data[prefix + 'monitor'] = 'data:text/plain,Code played successfully to cue stage ' + data[prefix + 'cue'];
        } else if (data[prefix + 'midi'] || data[prefix + 'midi2']) {
          data[prefix + 'monitor'] = 'data:text/plain,Code played to send MIDI (disklavier?)';
        } else if (data[prefix + 'app']) {
          data[prefix + 'monitor'] = 'data:text/plain,Code played to send notification (app)';
        } else if (data[prefix + 'v.mc'] || data[prefix + 'v.mc2']) {
          data[prefix + 'monitor'] = 'data:text/plain,Code played to trigger visual (approach?)';
        } else {
          data[prefix + 'monitor'] = 'data:text/plain,stage ' + data.stage + ' ' + prefix + ' triggered!';
        }
      }
    }
    if (data.meifile == null) {
      console.log('WARNING: no meifile specified for stage ' + data.stage);
      data.meifile = data.stage + '.mei';
    }
    control = {
      inputUrl: 'delay:stage:' + data.stage,
      actions: [],
      poststate: {}
    };
    nexturi = encodeURIComponent(data.stage);
    nextexp = JSON.stringify(data.meifile);
    control.actions.push({
      url: '{{meldsessionpost}}',
      post: true,
      contentType: 'application/ld+json',
      body: '{"oa:hasTarget":{ "@id": "{{meldsession}}"}, "oa:motivatedBy": { "@id": "motivation:createNextSession" }, "oa:hasBody":{"@id":"{{meldscoreuri}}' + nexturi + '"} }'
    });
    control.poststate.meldnextmeifile = nextexp;
    control.poststate.cued = "true";
    ex.controls.push(control);
    control = {
      inputUrl: 'delay:stage_nomeld:' + data.stage,
      actions: [],
      poststate: {}
    };
    nexturi = encodeURIComponent(data.stage);
    nextexp = JSON.stringify(data.meifile);
    control.poststate.meldnextmeifile = nextexp;
    control.poststate.cued = "true";
    ex.controls.push(control);
  }

  numflagvars = Math.ceil(numstages / BITS_PER_FLAGVAR);

  for (sfi = q = 1, ref12 = numflagvars; 1 <= ref12 ? q <= ref12 : q >= ref12; sfi = 1 <= ref12 ? ++q : --q) {
    ex.parameters.initstate['stageflags' + (sfi - 1)] = 0;
  }

  readmeifile = function(meifile) {
    var mei, meidir;
    meidir = configdir;
    if (config.meidir) {
      meidir = relpath(config.meidir, configdir);
    }
    meifile = relpath(meifile, meidir);
    mei = null;
    try {
      mei = fs.readFileSync(meifile, 'utf8');
      if (mei.length > 0 && mei.charCodeAt(0) !== 60 && mei.charCodeAt(0) !== 65279) {
        mei = fs.readFileSync(meifile, 'ucs2');
        if (mei.length > 0 && mei.charCodeAt(0) !== 60 && mei.charCodeAt(0) !== 65279) {
          console.log('ERROR: file does not seem to be utf16 or utf8 XML: ' + meifile);
          return null;
        }
      }
      return mei;
    } catch (error) {
      e = error;
      console.log('ERROR: reading mei file ' + meifile + ': ' + e.message);
      return null;
    }
  };

  writemeifile = function(meifile, text) {
    var mei, meidir;
    meidir = configdir;
    if (config.meioutdir) {
      meidir = relpath(config.meioutdir, configdir);
    }
    meifile = relpath(meifile, meidir);
    console.log('Write mei file ' + meifile);
    try {
      return mei = fs.writeFileSync(meifile, text, 'utf8');
    } catch (error) {
      e = error;
      return console.log('ERROR: writing mei file ' + meifile + ': ' + e.message);
    }
  };

  readmeiids = function(meifile) {
    var mei;
    mei = readmeifile(meifile);
    if (mei == null) {
      return {};
    }
    return getCodeIds(mei);
  };

  meicolorcue = (ref13 = config.meicolorcue) != null ? ref13 : '';

  meicolormidi = (ref14 = config.meicolormidi) != null ? ref14 : '#00d';

  meicolorapp = (ref15 = config.meicolorapp) != null ? ref15 : '#080';

  meicolorother = (ref16 = config.meicolorother) != null ? ref16 : '#666';

  processmeifile = function(meifile, data, meiids) {
    var color, fragments, len3, len4, mc, mei, meiout, meitext, mi, midi, nmidis, note, notes, pix, pmidis, pnotes, t, u;
    meitext = readmeifile(meifile);
    if (meitext == null) {
      return;
    }
    mei = meiutils.parse(meitext);
    if (mei == null) {
      console.log('Could not parse mei file ' + data.mei);
      writemeifile(meifile, meitext);
    }
    for (mi = t = 0, len3 = mcs.length; t < len3; mi = ++t) {
      mc = mcs[mi];
      if (!data[mc + 'name']) {
        continue;
      }
      marker = ex.markers.find(function(m) {
        return m.title === data[mc + 'name'];
      });
      if (!marker) {
        console.log('ERROR: no marker ' + data[mc + 'name']);
        continue;
      }
      if (marker.code == null) {
        console.log('No code for marker ' + data[mc + 'name'] + ' in ' + meifile);
        continue;
      }
      if ((data[mc] == null) || '' === data[mc]) {
        console.log('No measure for marker ' + data[mc + 'name'] + ' in ' + meifile);
        continue;
      }
      fragments = getfragmentids(data[mc], meiids);
      notes = meiutils.getnotes(mei, fragments);
      pnotes = marker.code.split(',');
      pmidis = (pnotes.map(meiutils.notetomidi)).filter((function(_this) {
        return function(m) {
          return m != null;
        };
      })(this));
      pix = 0;
      nmidis = [];
      for (u = 0, len4 = notes.length; u < len4; u++) {
        note = notes[u];
        if (pix >= pmidis.length) {
          break;
        }
        midi = meiutils.getmidinote(note);
        if (!midi) {
          continue;
        }
        nmidis.push(midi);
        if (midi === pmidis[pix]) {
          color = meicolorother;
          if (data[mc + 'cue']) {
            color = meicolorcue;
          } else if (data[mc + 'midi'] || data[mc + 'midi2']) {
            color = meicolormidi;
          } else if (data[mc + 'app'] || data[mc + 'v.mc'] || data[mc + 'v.mc2']) {
            color = meicolorapp;
          }
          if ((color != null) && color !== '') {
            meiutils.colornote(note, color);
          }
          pix++;
        }
      }
      if (pix === 0) {
        console.log('Warning: did not find notes for code ' + data[mc + 'name'] + ' to highlight in ' + data.meifile + ' at ' + data[mc] + ' = ' + fragments);
        console.log('pattern: ' + marker.code + ' -> ' + pmidis);
        console.log('notes: ' + nmidis);
      } else if (pix < pmidis.length) {
        console.log('Warning: find only ' + pix + '/' + pmidis.length + ' notes for code ' + data[mc + 'name'] + ' to highlight in ' + data.meifile + ' at ' + data[mc] + ' = ' + fragments);
        console.log('pattern: ' + marker.code + ' -> ' + pmidis);
        console.log('notes: ' + nmidis);
      }
    }
    meiout = meiutils.serialize(mei);
    return writemeifile(meifile, meiout);
  };

  getfragmentids = function(text, meiids) {
    var fragments, id, ids, label, labels, len3, len4, t, u;
    labels = String(text).split(',');
    fragments = [];
    for (t = 0, len3 = labels.length; t < len3; t++) {
      label = labels[t];
      if (label !== '') {
        if ((label.indexOf('#')) === 0) {
          fragments.push(label);
        } else {
          ids = meiids[label];
          if (ids == null) {
            console.log('Warning: could not find measure "' + label + '" in meifile');
          } else {
            for (u = 0, len4 = ids.length; u < len4; u++) {
              id = ids[u];
              fragments.push('#' + id);
            }
          }
        }
      }
    }
    return fragments;
  };

  for (r = t = 1; t <= 1000; r = ++t) {
    cell = sheet[cellid(0, r)];
    if (cell === void 0) {
      break;
    }
    if (cell.v == null) {
      continue;
    }
    data = stages[cell.v];
    meiids = readmeiids(data.meifile);
    meldstage = {
      stage: data.stage,
      next: data.next,
      cue: [],
      meifile: data.meifile,
      mcs: []
    };
    if (data.auto_cue != null) {
      meldstage.cue = data.auto_cue.split('/');
    }
    meldout.push(meldstage);
    control = {
      inputUrl: 'button:cue ' + data.stage,
      actions: [],
      poststate: {}
    };
    ex.controls.push(control);
    control.actions.push({
      url: '{{meldsessionpost}}',
      post: true,
      contentType: 'application/json',
      body: '{"oa:hasTarget": { "@id": "{{meldsession}}"}, "oa:motivatedBy": { "@id": "motivation:createNextSession" }, "oa:hasBody": { "@id": "{{meldscoreuri}}' + encodeURIComponent(data.stage) + '"} }'
    });
    control.poststate.meldnextmeifile = JSON.stringify(data.meifile);
    control.poststate.cued = "true";
    control = {
      inputUrl: 'post:meld.load',
      actions: [],
      poststate: {}
    };
    control.precondition = 'params.meldmei==(meldmeiuri+' + (JSON.stringify(encodeURIComponent(data.meifile))) + ')';
    control.poststate.meldnextmeifile = 'null';
    ex.controls.push(control);
    set_stage(control, data);
    add_actions(control, 'auto_', data, true);
    control.poststate.meldmei = 'params.meldmei';
    control.poststate.meldsessionpost = 'params.meldcollection.replace("/sessions", "/sessions/bypass")';
    control.poststate.meldsession = 'params.meldcollection';
    if (data._index === 0) {
      control.actions.push({
        url: 'emit:vStart:mobileapp:{{performanceid}}:' + data.stage
      });
      for (sfi = u = 1, ref17 = numflagvars; 1 <= ref17 ? u <= ref17 : u >= ref17; sfi = 1 <= ref17 ? ++u : --u) {
        control.poststate['stageflags' + (sfi - 1)] = sfi === 0 ? 1 : 0;
      }
    } else if (data._index === (numstages - 1)) {
      control.actions.push({
        url: 'emit:vStop:mobileapp:{{performanceid}}'
      });
    } else {
      control.actions.push({
        url: 'emit:vStageChange:mobileapp:{{performanceid}}:{{stage}}->' + data.stage
      });
    }
    meitext = readmeifile(data.meifile);
    mei = meitext != null ? meiutils.parse(meitext) : null;
    codetitles = {};
    challengecount = 0;
    for (mi = x = 0, len3 = mcs.length; x < len3; mi = ++x) {
      mc = mcs[mi];
      if (!data[mc + 'name']) {
        continue;
      }
      meldmc = {
        name: data[mc + 'name'],
        meielements: []
      };
      if (data[mc + 'cue'] != null) {
        meldmc.cue = data[mc + 'cue'];
        meldmc.type = 'challenge';
        challengecount = challengecount + 1;
      } else if (data[mc + 'midi'] || data[mc + 'midi2']) {
        meldmc.type = 'disklavier';
      } else if (data[mc + 'app']) {
        meldmc.type = 'approaching';
      }
      meldstage.mcs.push(meldmc);
      if (data[mc + 'app'] != null) {
        meldmc.app = (data[mc + 'app'].split(':'))[0];
      }
      marker = get_marker(ex, data[mc + 'name'], 'stage ' + data.stage + ' ' + mc + 'name');
      if (marker.precondition.length > 0) {
        console.log('ERROR: coding error: marker found with non-empty precondition: ' + marker.precondition);
      }
      marker.precondition = 'stage=="' + data.stage + '"';
      marker.precondition += ' && (stagecodeflags & ' + (1 << mi) + ')==0';
      marker.poststate.stagecodeflags = 'stagecodeflags | ' + (1 << mi);
      if (codetitles[marker.title] === void 0) {
        codetitles[marker.title] = [];
      } else {
        ref18 = codetitles[marker.title];
        for (y = 0, len4 = ref18.length; y < len4; y++) {
          ct = ref18[y];
          marker.precondition += ' && (stagecodeflags & ' + (1 << ct) + ')!=0';
        }
      }
      codetitles[marker.title].push(mi);
      add_actions(marker, mc, data);
      if ((data[mc] != null) && data[mc] !== '') {
        marker.actions.push({
          url: '{{meldsessionpost}}',
          post: true,
          contentType: 'application/ld+json',
          body: '{"oa:hasTarget": { "@id": "{{meldscoreuri}}' + data.stage + '#' + data[mc + 'name'] + '"},"oa:motivatedBy": { "@id": "motivation:muzicodeTriggered" }}'
        });
        fragments = getfragmentids(data[mc], meiids);
        for (z = 0, len5 = fragments.length; z < len5; z++) {
          fragment = fragments[z];
          meldmc.meielements.push(fragment);
        }
        if (marker.code != null) {
          notes = meiutils.getnotes(mei, fragments);
          pnotes = marker.code.split(',');
          pmidis = (pnotes.map(meiutils.notetomidi)).filter((function(_this) {
            return function(m) {
              return m != null;
            };
          })(this));
          pix = 0;
          nmidis = [];
          for (i1 = 0, len6 = notes.length; i1 < len6; i1++) {
            note = notes[i1];
            if (pix >= pmidis.length) {
              break;
            }
            midi = meiutils.getmidinote(note);
            if (!midi) {
              continue;
            }
            nmidis.push(midi);
            if (midi === pmidis[pix]) {
              pix++;
              meldmc.meielements.push('#' + (note.getAttribute('xml:id')));
            }
          }
        }
      }
    }
    if (challengecount > 1) {
      ref19 = meldstage.mcs;
      for (j1 = 0, len7 = ref19.length; j1 < len7; j1++) {
        meldmc = ref19[j1];
        if (meldmc.type === 'challenge') {
          meldmc.type = 'choice';
        }
      }
    }
    if (defaultprojection !== '' && (data['default_cue'] != null)) {
      control = {
        inputUrl: 'event:end:' + defaultprojection,
        actions: [],
        precondition: 'stage==' + (JSON.stringify(data.stage)) + ' && !cued',
        poststate: {}
      };
      ex.controls.push(control);
      add_actions(control, 'default_', data);
    }
    processmeifile(data.meifile, data, meiids);
  }

  errors = 0;

  for (stage in stages) {
    data = stages[stage];
    for (k1 = 0, len8 = prefixes.length; k1 < len8; k1++) {
      prefix = prefixes[k1];
      if (data[prefix + 'cue'] != null) {
        nextstages = ((data[prefix + 'cue'].split('/')).map((function(_this) {
          return function(s) {
            return s.trim();
          };
        })(this))).filter((function(_this) {
          return function(s) {
            return s.length > 0;
          };
        })(this));
        for (l1 = 0, len9 = nextstages.length; l1 < len9; l1++) {
          nextstage = nextstages[l1];
          if (stages[nextstage] == null) {
            console.log('ERROR: stage ' + stage + ' ' + prefix + 'cue refers to unknown stage "' + nextstage + '"');
            errors++;
          }
        }
      }
    }
  }

  control = {
    inputUrl: 'button:clear flags',
    actions: [],
    poststate: {}
  };

  for (sfi = m1 = 1, ref20 = numflagvars; 1 <= ref20 ? m1 <= ref20 : m1 >= ref20; sfi = 1 <= ref20 ? ++m1 : --m1) {
    control.poststate['stageflags' + (sfi - 1)] = 0;
  }

  control.poststate.stagecodeflags = 0;

  control = {
    inputUrl: 'event:load',
    actions: [],
    poststate: {}
  };

  ex.controls.push(control);

  control.poststate.stage = '"_loaded"';

  ref21 = ['v.animate', 'v.mc', 'v.background', 'v.weather'];
  for (n1 = 0, len10 = ref21.length; n1 < len10; n1++) {
    channel = ref21[n1];
    if (!(channel === 'v.background' && (config.forcebackgroundurl != null))) {
      control.actions.push({
        channel: channel,
        url: ''
      });
    }
  }

  control = {
    inputUrl: 'button:next piece',
    actions: []
  };

  ex.controls.push(control);

  control.actions.push({
    url: '{{meldsessionpost}}',
    post: true,
    contentType: 'application/ld+json',
    body: '{"oa:hasTarget": { "@id": "{{meldsession}}"},"oa:motivatedBy": { "@id": "motivation:transitionToNextSession" }}'
  });

  control = {
    inputUrl: 'button:pedal',
    actions: []
  };

  ex.controls.push(control);

  control.actions.push({
    url: 'http://localhost:3000/input',
    post: true,
    contentType: 'application/x-www-form-urlencoded',
    body: 'name=pedal'
  });

  control = {
    inputUrl: 'button:back',
    actions: []
  };

  ex.controls.push(control);

  control.actions.push({
    url: '{{meldsessionpost}}',
    post: true,
    contentType: 'application/ld+json',
    body: '{"oa:hasTarget": { "@id": "{{meldsession}}"},"oa:motivatedBy": { "@id": "motivation:prevPageOrPiece"} }'
  });

  control = {
    inputUrl: 'button:Fake meld',
    actions: [],
    precondition: '!!meldnextmeifile'
  };

  ex.controls.push(control);

  control.actions.push({
    url: 'http://localhost:3000/input',
    post: true,
    contentType: 'application/x-www-form-urlencoded',
    body: 'name=meld.load&meldmei={{meldmeiuri}}{{encodeURIComponent(meldnextmeifile)}}&meldcollection='
  });

  control = {
    inputUrl: 'post:pedal',
    actions: []
  };

  ex.controls.push(control);

  control.actions.push({
    url: '{{meldsessionpost}}',
    post: true,
    contentType: 'application/ld+json',
    body: '{"oa:hasTarget": { "@id": "{{meldsession}}"},"oa:motivatedBy": { "@id": "motivation:nextPageOrPiece" }}'
  });

  control = {
    inputUrl: 'post:pedal.back',
    actions: []
  };

  ex.controls.push(control);

  control.actions.push({
    url: '{{meldsessionpost}}',
    post: true,
    contentType: 'application/ld+json',
    body: '{"oa:hasTarget": { "@id": "{{meldsession}}"},"oa:motivatedBy": { "@id": "motivation:prevPageOrPiece" }}'
  });

  ref22 = ex.markers;
  for (o1 = 0, len11 = ref22.length; o1 < len11; o1++) {
    marker = ref22[o1];
    if (marker.precondition === '' && marker.actions.length === 0) {
      unused = true;
      ref23 = marker.poststate;
      for (k in ref23) {
        v = ref23[k];
        unused = false;
        break;
      }
      if (unused) {
        console.log('Note: disabling unused marker "' + marker.title + '"');
        marker.precondition = 'false';
      }
    }
  }

  console.log('write experience ' + exoutfile);

  fs.writeFileSync(exoutfile, JSON.stringify(ex, null, '  '), {
    encoding: 'utf8'
  });

  viewconfig = viewgen.get();

  console.log('write climbview file ' + viewoutfile);

  fs.writeFileSync(viewoutfile, JSON.stringify(viewconfig, null, '  '), {
    encoding: 'utf8'
  });

  console.log('write meld config file ' + meldoutfile);

  fs.writeFileSync(meldoutfile, JSON.stringify(meldout, null, '  '), {
    encoding: 'utf8'
  });

  console.log('done');

  return errors;

}).call(this);
